using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Schema;

namespace Billas.Xml.Generation
{
    public class XmlSchemaMerge : IXmlSchemaMerge
    {
        public void Merge(string xsdFileWithOtherIncludedOrLinkedXsdFiles, string outputFilePath, XmlSchemaMergeSettings settings = null)
        {
            if (settings == null) settings = XmlSchemaMergeSettings.Default;

            var schemaProvider = new XmlSchemaProvider(xsdFileWithOtherIncludedOrLinkedXsdFiles);

            if (settings.SetSchemaVersion == null)
            {
                settings.SetSchemaVersion = new Version(schemaProvider.SchemaVersion.Major, schemaProvider.SchemaVersion.Minor, schemaProvider.SchemaVersion.Build + 1);
            }

            if (string.IsNullOrEmpty(outputFilePath))
            {
                outputFilePath = $"{Path.GetDirectoryName(schemaProvider.Path)}{Path.DirectorySeparatorChar}{Path.GetFileNameWithoutExtension(schemaProvider.Path)}_{settings.SetSchemaVersion}.xsd";
            }

            var mode = settings.OverwriteExisting ? FileMode.Create : FileMode.CreateNew;
            using (var file = new FileStream(outputFilePath, mode, FileAccess.Write))
            {
                Merge(schemaProvider.CompiledSchema, file, settings);
            }
        }

        public void Merge(XmlSchemaSet schemaSet, Stream outStream, XmlSchemaMergeSettings settings = null)
        {
            if (settings == null) settings = XmlSchemaMergeSettings.Default;

            if (schemaSet.Count != 1)
                throw new IndexOutOfRangeException($"Cannot write {schemaSet.Count} schemas to file.");
            
            var originalSchema = schemaSet.Schemas().OfType<XmlSchema>().First();
            
            var numberOfSimpleTypes = originalSchema.Items.OfType<XmlSchemaSimpleType>().Count();
            var numberOfComplexTypes = originalSchema.Items.OfType<XmlSchemaComplexType>().Count();
            var numberOfElements = originalSchema.Items.OfType<XmlSchemaElement>().Count();
            var msgLine1 = $"Orginal schema had {schemaSet.Count} schemas containing {schemaSet.GlobalTypes.Count} types; {numberOfSimpleTypes} simpleTypes, {numberOfComplexTypes} complexTypes and {numberOfElements} elements.";

            var schema = CopyWithoutIncludeTo(originalSchema, settings);

            numberOfSimpleTypes = schema.Items.OfType<XmlSchemaSimpleType>().Count();
            numberOfComplexTypes = schema.Items.OfType<XmlSchemaComplexType>().Count();
            numberOfElements = originalSchema.Items.OfType<XmlSchemaElement>().Count();
            var msgLine2 = $"Generated schema contains {schema.Items.Count} types; {numberOfSimpleTypes} simpleTypes, {numberOfComplexTypes} complexTypes and {numberOfElements} elements.";

            XDocument doc;
            using (var memoryStream = new MemoryStream())
            using (var xmlWriter = XmlWriter.Create(memoryStream))
            {
                schema.Write(xmlWriter);
                xmlWriter.Flush();
                memoryStream.Position = 0;
                doc = XDocument.Load(memoryStream);
            }

            var name = Assembly.GetEntryAssembly().GetName();
            var copyComment = new XComment($"\n[auto-generated]\n\tThis schema was generated by a tool.\n\t{name.Name} {GetType().Name} {name.Version.ToString(3)}\n\tChanges to this file may cause incorrect behavior and will be lost if the file is regenerated.\n\n\t{msgLine1}\n\t{msgLine2}\n[/auto-generated]\n");
            doc.AddFirst(copyComment);
            

            using (var xmlWriter = XmlWriter.Create(outStream, new XmlWriterSettings {Indent = true, Encoding = Encoding.UTF8}))
            {
                doc.WriteTo(xmlWriter);
            }
        }

        private XmlSchema CopyWithoutIncludeTo(XmlSchema inSchema, XmlSchemaMergeSettings settings)
        {
            var outSchema = new XmlSchema
            {
                AttributeFormDefault = inSchema.AttributeFormDefault,
                BlockDefault = inSchema.BlockDefault,
                ElementFormDefault = inSchema.ElementFormDefault,
                FinalDefault = inSchema.FinalDefault,
                Id = inSchema.Id,
                TargetNamespace = inSchema.TargetNamespace,
                Version = settings.SetSchemaVersion?.ToString(3)
            };
            
            foreach (var xmlQualifiedName in inSchema.Namespaces.ToArray())
                outSchema.Namespaces.Add(xmlQualifiedName.Name, xmlQualifiedName.Namespace);

            
            AddTableToSchema(outSchema, inSchema.AttributeGroups);
            AddTableToSchema(outSchema, inSchema.Attributes);
            AddTableToSchema(outSchema, inSchema.Elements);
            AddTableToSchema(outSchema, inSchema.Groups);
            AddTableToSchema(outSchema, inSchema.Notations);

            if (settings.IncludeOnlyUsedTypes)
            {
                var tmpSchema = new XmlSchema();
                foreach (XmlSchemaElement elementsValue in inSchema.Elements.Values)
                {
                    if (elementsValue.ElementSchemaType is XmlSchemaComplexType complex)
                    {
                        AddComplexType(tmpSchema, inSchema.SchemaTypes, complex);
                    }
                }

                foreach (var complexType in tmpSchema.Items.OfType<XmlSchemaComplexType>())
                {
                    outSchema.Items.Add(complexType);
                }

                
                foreach (var simpleType in tmpSchema.Items.OfType<XmlSchemaSimpleType>().OrderBy(t => t.Name))
                {
                    outSchema.Items.Add(simpleType);
                }
            }
            else
            {
                AddTableToSchema(outSchema, inSchema.SchemaTypes);
            }

            if(settings.SetSchemaVersion != null)
                SetSchemaVersionAttribute(outSchema, settings.SetSchemaVersion.ToString(3));
            
            return outSchema;
        }

        private static void AddComplexType(XmlSchema schema, XmlSchemaObjectTable table, XmlSchemaComplexType complex)
        {
            if(complex.QualifiedName.Namespace == "http://www.w3.org/2001/XMLSchema") return;
            
            var obj = table[complex.QualifiedName];
            if (obj != null)
            {
                if(schema.Items.Contains(obj)) return;
                schema.Items.Add(obj);
            }

            if (complex.BaseXmlSchemaType?.Name != null)
            {
                if (complex.BaseXmlSchemaType is XmlSchemaComplexType c)
                    AddComplexType(schema, table, c);
                else if (complex.BaseXmlSchemaType is XmlSchemaSimpleType s)
                    AddSimpleType(schema, table, s);
            }

            if (complex.ContentTypeParticle is XmlSchemaGroupBase sequence)
            {
                foreach (XmlSchemaObject item in sequence.Items)
                {
                    AddSchemaObject(schema, table, item);
                }
            }
            
            foreach (XmlSchemaAttribute attribute in complex.AttributeUses.Values)
            {
                AddSimpleType(schema, table, attribute.AttributeSchemaType);
            }

        }

        private static void AddSimpleType(XmlSchema schema, XmlSchemaObjectTable table, XmlSchemaSimpleType simple)
        {
            if (simple.QualifiedName.Namespace == "http://www.w3.org/2001/XMLSchema") return;

            var obj = table[simple.QualifiedName];
            if (obj != null)
            {
                if (schema.Items.Contains(obj)) return;
                schema.Items.Add(obj);
            }

            if (simple.DerivedBy.HasFlag(XmlSchemaDerivationMethod.Union) && simple.Content is XmlSchemaSimpleTypeUnion union)
            {
                foreach(var x in union.BaseMemberTypes)
                    AddSimpleType(schema, table, x);
            }

            if (simple.BaseXmlSchemaType != null && simple.BaseXmlSchemaType is XmlSchemaSimpleType s)
            {
                AddSimpleType(schema, table, s);
            }
        }

        private static void AddSchemaObject(XmlSchema schema, XmlSchemaObjectTable table, XmlSchemaObject item)
        {
            if (item is XmlSchemaElement element)
            {
                
                if (element.ElementSchemaType is XmlSchemaComplexType comp)
                {
                    AddComplexType(schema, table, comp);
                }
                else if (element.ElementSchemaType is XmlSchemaSimpleType simple)
                {
                    AddSimpleType(schema, table, simple);
                }
            }

            else if (item is XmlSchemaParticle particle)
            {
                if (particle is XmlSchemaGroupBase sequence)
                {
                    foreach (XmlSchemaObject i in sequence.Items)
                    {
                        AddSchemaObject(schema, table, i);
                    }
                }
            }
        }

        private static void SetSchemaVersionAttribute(XmlSchema schema, string schemaVersion)
        {
            foreach (XmlSchemaObject item in schema.Items)
            {
                if (item is XmlSchemaComplexType complex)
                {
                    foreach (var attributeUsesValue in complex.AttributeUses.Values)
                    {
                        if (attributeUsesValue is XmlSchemaAttribute attribute && attribute.Name == "schemaVersion" && !string.IsNullOrEmpty(attribute.FixedValue))
                        {
                            attribute.FixedValue = schemaVersion;
                        }
                    }
                }
            }
        }

        private static void AddTableToSchema(XmlSchema outSchema, XmlSchemaObjectTable table)
        {
            var e = table.GetEnumerator();

            while (e.MoveNext())
            {
                outSchema.Items.Add((XmlSchemaObject)e.Value);
            }
        }
    }
}